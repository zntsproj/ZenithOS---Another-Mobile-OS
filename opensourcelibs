# ZenithOS Source Code

This md contains the source code for various components of the ZenithOS operating system. We believe in open-source development and want to make our code accessible to the community for learning, collaboration, and improvement.

The code within this repository is released under the [Specify License Name, e.g., MIT License]. This license grants you the freedom to use, modify, and distribute the code, subject to the terms and conditions outlined in the license file. Please review the license file carefully before using or distributing this code.
We encourage contributions and collaboration from the community. If you find any bugs, have suggestions for improvements, or want to contribute new features, please feel free to submit pull requests or open issues on this repository.

libirda.so -- Source Code (NOT FINALLY DONE)
#include <jni.h>
#include <string>
#include <android/log.h>
#include <fcntl.h>
#include "socket.h"
#include "irda.h"
#include <unistd.h> //  for  close()
#include <errno.h>  //  for  errno
#include <string.h> //  fot  strerror()

//ATTENTION, ALL COMMENTS WILL BE IN RUSSIAN NOW
#define TAG "IrDA_JNI"

extern "C" JNIEXPORT jstring JNICALL
Java_com_example_app_IrDAController_sendIrDAData(JNIEnv *env, jobject /* this */, jstring data) {
    //  Проверяем,  что  переданная  строка  не  равна  null
    if (data == nullptr) {
        __android_log_print(ANDROID_LOG_ERROR, TAG, "Error: Data is null");
        return env->NewStringUTF("Error: Data is null");
    }

    //  Получаем  C-строку  из  Java-строки
    const char *nativeData = env->GetStringUTFChars(data, nullptr);

    //  Проверяем,  что  преобразование  прошло  успешно
    if (nativeData == nullptr) {
        __android_log_print(ANDROID_LOG_ERROR, TAG, "Error: Failed to convert data to C string");
        return env->NewStringUTF("Error: Failed to convert data to C string");
    }

    //  Проверяем  наличие  IrDA
    if (access("/dev/irda0", F_OK) == -1) {
        __android_log_print(ANDROID_LOG_ERROR, TAG, "Error: IrDA device not found");
        return env->NewStringUTF("Error: IrDA device not found");
    }

    //  Получаем  файловый  дескриптор  устройства  IrDA
    int irda_device_fd = open("/dev/irda0", O_RDWR);

    if (irda_device_fd < 0) {
        __android_log_print(ANDROID_LOG_ERROR, TAG, "Error: Failed to open IrDA device: %s", strerror(errno));
        return env->NewStringUTF("Error: Failed to open IrDA device");
    }

    //  Отправляем  данные  через  IrDA
    int result = ioctl(irda_device_fd, IRDA_CMD_SEND_DATA, nativeData);

    if (result < 0) {
        __android_log_print(ANDROID_LOG_ERROR, TAG, "Error: Failed to send data via IrDA: %s", strerror(errno));
        close(irda_device_fd);
        return env->NewStringUTF("Error: Failed to send data via IrDA");
    }

    //  Закрываем  файловый  дескриптор
    close(irda_device_fd);

    //  Освобождаем  ресурсы
    env->ReleaseStringUTFChars(data, nativeData);

    return env->NewStringUTF("Data sent successfully");
}

(experienced developers can fix this file)

libzenithserv.so -- Source Code

#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>

int main() {
  // Создаем сокет
  int server_socket = socket(AF_INET, SOCK_STREAM, 0);
  if (server_socket == 0) {
    std::cerr << "Ошибка создания сокета" << std::endl;
    return 1;
  }

  // Задаем адрес и порт сервера
  sockaddr_in address;
  address.sin_family = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons(8080);

  // Привязываем сокет к адресу
  if (bind(server_socket, (struct sockaddr *)&address, sizeof(address)) < 0) {
    std::cerr << "Ошибка привязки сокета" << std::endl;
    return 1;
  }

  // Начинаем прослушивание соединений
  if (listen(server_socket, 3) < 0) {
    std::cerr << "Ошибка прослушивания" << std::endl;
    return 1;
  }

  std::cout << "Сервер запущен на порту 8080" << std::endl;

  while (true) {
    // Принимаем соединение
    int new_socket = accept(server_socket, (struct sockaddr *)&address, (socklen_t*)&address);
    if (new_socket < 0) {
      std::cerr << "Ошибка принятия соединения" << std::endl;
      continue;
    }

    // Отправляем сообщение клиенту
    char buffer[1024] = {0};
    read(new_socket, buffer, 1024);
    std::cout << "Получено сообщение от клиента: " << buffer << std::endl;
    const char *hello = "Привет от сервера!";
    send(new_socket, hello, strlen(hello), 0);

    // Закрываем соединение
    close(new_socket);
  }

  return 0;
}

(tested, everything works)

libfddi.h

// Этот код предназначен для работы в ZenithOS, где есть root-права.
// Не рекомендуется запускать этот код на не рутированном устройстве, 
// так как он может не работать или привести к нежелательным последствиям.
//
// Код принимает пакеты FDDI на интерфейсе "fddi0". 
// Убедитесь, что этот интерфейс существует в вашей системе.
//
// Дополнительная информация:
// - Код выводит содержимое пакета в шестнадцатеричном виде.
// - Код подсчитывает количество полученных пакетов.
// - Код выводит статистику каждые 10 секунд.


// This code is intended to run on ZenithOS, which has root privileges.
// It is not recommended to run this code on a non-rooted device, 
// as it may not work or lead to undesirable consequences.
//
// The code receives FDDI packets on the "fddi0" interface. 
// Make sure this interface exists on your system.
//
// Additional information:
// - The code prints the contents of the packet in hexadecimal.
// - The code counts the number of packets received.
// - The code prints statistics every 10 seconds.auto 




#include <sys/socket.h>
#include <netinet/in.h>
#include <net/if.h>
#include "fddi.h"
#include "if_hddi.h"
#include "fddi2.h"
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>

int main() {
  int fd = socket(PF_PACKET, SOCK_DGRAM, 0);
  if (fd < 0) {
    perror("socket creation failed");
    return 1;
  }

  struct sockaddr_ll sll;
  memset(&sll, 0, sizeof(sll));
  sll.sll_family = AF_PACKET;
  sll.sll_ifindex = if_nametoindex("fddi0");
  sll.sll_protocol = htons(ETH_P_ALL); // Принимаем все протоколы

  if (bind(fd, (struct sockaddr *)&sll, sizeof(sll)) < 0) {
    perror("bind failed");
    return 1;
  }

  // Переменные для подсчёта пакетов и времени
  unsigned long long packet_count = 0;
  time_t last_stats_time = time(NULL);

  // Дальнейшая обработка пакетов FDDI
  while (1) {
    char buffer[FDDI_K_LLC_LEN];
    int bytes_received = recv(fd, buffer, sizeof(buffer), 0);
    if (bytes_received < 0) {
      perror("recv failed");
      break;
    }

    // Обработка принятых данных
    printf("Received %d bytes on FDDI interface:\n", bytes_received);

    // Вывод содержимого пакета в шестнадцатеричном виде
    for (int i = 0; i < bytes_received; i++) {
      printf("%02x ", (unsigned char)buffer[i]);
      if ((i + 1) % 16 == 0) {
        printf("\n");
      }
    }
    printf("\n");

    // Подсчёт пакетов
    packet_count++;

    // Вывод статистики каждые 10 секунд
    time_t current_time = time(NULL);
    if (current_time - last_stats_time >= 10) {
      printf("Received %llu packets in the last 10 seconds\n", packet_count);
      packet_count = 0;
      last_stats_time = current_time;
    }
  }

  close(fd);
  return 0;
}

we believe in open source development
